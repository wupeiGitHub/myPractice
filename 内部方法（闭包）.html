<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script>
			//----------------闭包-----------------
			//概念：闭包就是能够读取其他函数内部变量的函数。内部函数可以访问外面的变量， 函数外面可以获取到函数内部的局部变量。
				//由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
				//所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
//			 优点: 1)可以读取函数内部的变量 
//			 	 2)让这些变量的值始终保存在内存中
			//缺点：闭包能保存外部的变量，所以占内存
			//注意：
			//1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
			//2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
		
			//------------案例
			　　function f1(){
			　　　　var n=999;
			　　　　nAdd=function(){n+=1} //也相当于闭包，无var声明其实是全局的函数，可以在函数外部对函数内部的局部变量进行操作
			　　　　function f2(){ //闭包
			　　　　　　alert(n);
			　　　　}
			　　　　return f2;
			　　}
			  //调用
			　　var result=f1();
			　　	result(); // 999
			　　	nAdd(); //可以在函数外部对函数内部的局部变量进行操作
			　	result(); // 1000 = 999+1
				nAdd();
			　	result(); // 1001 = 1000+1
				
				
		  //--------------案例2
		　　//var name = "The Window";
		　　var object = {
		　　　　name : "My Object",
		　　　　getNameFunc : function(){
				console.log("1this===", this); //object:{name: "My Object", getNameFunc: ƒ}
		　　　　　　return function(){
				   console.log("2this===", this); //Window
		　　　　　　　　return this.name;
		　　　　　　};
		　　　　}
		　　};
		  console.log("111111===", object.getNameFunc()()); //The Window
			
		  //-------------------案例3
		  // var name = "The Window";
		　　var object = {
		　　　　name : "My Object",
		　　　　getNameFunc : function(){
				//console.log("this1===", this); //指向的是object对象
		　　　　　　var that = this;
		　　　　　　return function(){
				   //console.log("this2===", this); //执行window
		　　　　　　　　return that.name;
		　　　　　　};
		　　　　}
		　　};
		  console.log("2222222===",object.getNameFunc()());
			
			//案例4
			/*var BaseClass = function() {  
			    var method1 = function() {  
			        console.log("1: Internal method");  
			    };  
			    var method2 = function() {  
			        console.log("2: call Internal method");  
			        method1();  
			    };  
			    this.method3 = function(){  
			        method2();  
			    }  
			};  
			var instance1 = new BaseClass();  
			//instance1.method1();// 会报错，因为method1是BaseClass中定义的内部变量，作用域只有在内部可见（闭包）  
			instance1.method3();//会先后调用method2和method1 */
			
			

			
		</script>
	</head>
	<body>
	</body>
</html>
