<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>类型隐式转换</title>
		<script>
			
			
			
			// 1.加号+,当左右两边有字符串时会进行字符串String()的隐式类型转换
			console.log("10+'20' : ", 10+'20'); //1020 ===> '10'+'20'
			//--------------2. +正号和-负号,会把内容进行Number的隐式类型转换
			console.log("+'123abb' : ", +"123abb"); //NaN
			console.log("-'123' : ", -"123", typeof -"123"); // -123 
			//------------3.isNaN会进行 Number隐式转换, Number()转换后的值和NaN比较.相等返回true,反之返回false
			
			console.log("Number('') : ",Number('')); // 0
			console.log("Number(null) : ",Number(null)); // 0
			console.log("Number(undefined) : ", Number(undefined)); // NaN
			console.log("isNaN(null) : ", isNaN(null)); // false ==> 0 == NaN
			console.log("isNaN(undefined) : ", isNaN(undefined)); // false ==> 0 == NaN
			
// 			//-----------4: == 和!= 的左右比较类型不同时的隐式转换规则如下
// 			1)如果等号两边有一边是布尔值则先把布尔转为数字再进行下步的比较.(true转后是1, false为0)
// 			2)如果等号一边是字符串,另一边是数值则将 字符串强制转换为数值后再进行比较;
// 			3)如果等号一边是对象,另一边不是对象,则把对象调用toValueOf()方法返回的值如果是基本数据类型就按照以上1和2步骤再进行比较.如果不是就调用toString方法然后再比较
// 			4)其中null和undefined是特殊类型, 它们在与任何值比较时都不做任何类型转换, 与NaN比较时直接返回false
// 			5)如果等号两边都是对象,那么就比较两边指向的是否是同一个对象,是就返回true,反之返回false 
// 			
			
			
			//------------------------特殊的
			console.log("undefined == null :", undefined == null); //true
			console.log("null == null :", null == null); //true
			console.log("undefined == undefined :", undefined == undefined); //true
			console.log("undefined == 0 :", undefined == 0); //false
			console.log("null == 0 :", null == 0); //false
			console.log("null == '' :", null == ''); //false
			console.log("NaN == NaN :", NaN == NaN); // false
			console.log("NaN == 123 :", NaN == 123); // false
			
			console.log('---------------------------------------------------------')
			console.log("[] == [] :", [] == []); // false
			var arr1 = [1,3];
			var arr2 = arr1;
			console.log("arr1 == arr2 :", arr1 == arr2); // true
			console.log("arr1 === arr2 :", [arr1] === arr2); // true
			
			//-------------5.一边是对象。另一遍不是对象的比较-----------------------------
			//---------1)先把对象通过toValueOf()方法进行转换,得到的如果是原始类型在按照==的基本类型比较进行判断,
			//----------2)如果toValueOf方法拿到的不是原始内心则通过tostring方法进行字符串转换后再比较
			console.log(![]); // false
			console.log(!![]); // true
			console.log(!{}); // false
			console.log("[].valueOf() : ", [].valueOf(), typeof ([].valueOf())); // [] object
			console.log("[].toString() : ", [].toString(), typeof ([].toString()));  // string 空字符串
			
			console.log('' == false); //true
			console.log('' == 0); //true
			console.log(Number('') == 0); //true
			console.log('---------------');
			
			//1.得出[] == ![]的值
			//解析过程：1）[]==![]
				//2)  ---->(优先级：!优先级高于==) []==false 相当于，Number([])为0，Number(false)为0
				//3) ----->(两边类型不一致时，隐式转换为Number后再比较)   0==0   --->//true
			console.log("[] == ![] ", [] == ![]); //true
			//-------------------执行过程解析----------------
			//console.log("[] == [] ", [] == []); //false 对象和对象是不相等的，引用地址不一样
			//因为 [] 是对象，比较过程依ToPrimitive([]) == false 比较。ToPrimitive 默认是调用 toString 方法的，
			//于是 ToPrimitice([]) 等于空字符串，即''==false，然后ToNumber('')==0，即0==0，true。
			console.log("[].toString()", [].toString()); //空
			console.log("[]+''", []+''); //空
			console.log("Number([])", Number([])); //0
			console.log("Number('')", Number('')); //0
			console.log("Number('[]')", Number('[]')); //NaN
			console.log("[]  =》", !![]); //true- 双叹号表示把值转为boolean值, 类似强转Boolean([]) 
			console.log("Boolean([])  =》", Boolean([]) ); 
			console.log("![] =》", ![]); //false
			console.log(' [].valueOf() ', [].valueOf()); //[]
			console.log(' typeof [].valueOf() ', typeof [].valueOf()); //object
			console.log([].toString()); //''
			
			//--------------------有数字和字符串的比较-----------------------------
			console.log("3"==3); // 3=3 true
			console.log("1"==true); //1 = 1 true
			
			//--------------------对象的比较-----------------------------
			var obj = {
				 webName: "脚本之家",
				 url:"softwhy.com"
			}
			console.log(obj.toString()); //[object Object]
			console.log(obj.valueOf()); //{webName: "脚本之家", url: "softwhy.com"}
			
			var arr = [1, 2, 3];
			console.log(arr.valueOf()); //[1, 2, 3]
			console.log(arr.toString()); //1,2,3
			
			
			

			var arr = [];
			//arr.valueOf = function () { return "1"; }
			//arr.toString = function () { return "2"; }
			console.log(arr + "1"); //11 它值调用valueOf方法不调用toString方法
			
			var arr = [2];
			console.log(arr + "1");
			
			//大多数对象隐式转换为值类型都是首先尝试调用valueOf()方法。
			//但是Date对象是个例外，此对象的valueOf()和toString()方法都经过精心重写，默认是调用toString()方法，
			//比如使用+运算符，如果在其他算数运算环境中，则会转而调用valueOf()方法。
			
			var date = new Date();
			console.log("date-------------------");     
			console.log(date + "1");
			console.log(date + 1);
			console.log(date - 1);
			console.log(date * 1);
			
			
			//注意typeof和+ - 一样，是运算符，可以使用括号也可以不使用括号
			var a=true,b=true;
			console.log(" typeof a==b 返回值", typeof a==b); //false 
			console.log(" typeof a  返回值 ", typeof a); 
			//上面的执行步骤是， (typeof a) == b >>>>  boolean == true  >>>> false
			console.log(" typeof (a==b) 返回值 ", typeof (a==b)); //boolean
		</script>
	</head>
	<body>
	</body>
</html>