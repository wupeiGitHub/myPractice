<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script>
			//这种模式主要通过创建自定义的构造函数，从而定义自定义对象类型的属性和方法，来看下面例子
			//通过this指定属性或者函数，调用时需要用new 关键字实例化构造函数对象
			function Person(name, age) {
				 this.name = name;
				 this.age = age;
				 this.sayName = function() {
					console.log(this.name);
				 }
			}
			 
			var person1 = new Person("Nicholas", 29);
			var person2 = new Person("Greg", 27);
			console.log(person1.name); //Nicholas
			console.log(person2.name); //Greg
			person2.sayName(); //调用构造函数中的子函数
			
			 /*这里要说明一下，构造函数需要以一个大写字母开头，而非构造函数应该以一个小写字母开头，这个主要是为了区别构造函数和其它函数，构造函数其实本身也是函数，只是用来创建对象而已

    其中，要创建Person的新实例，需要使用new操作符，其实这里会经过4个步骤，首先，将会创建一个新对象，接着会将构造函数的作用域赋给新对象，this指向了这个对象，接着会执行构造函数中的代码，为这个新对象添加属性，最后会返回新对象

    优点：可以创建多个对象，解决对象的识别问题

    缺点：每个实例都会创建不同的function实例，而其实创建完成同样任务的function实例是很没有必要的

    这里还是要说明一下，对象类型的检测需要用到instanceof操作符，比如像上面的例子可以用下面的方法检测*/

	console.log(person1 instanceof Person); // true
	console.log(person2 instanceof Person); // true
	console.log(Person === Person); // true
	//console.log(typeof person1); // object
    //使用构造函数模式可以解决对象的识别问题，而这也是工厂模式无法办到的
		</script>
	</head>
	<body>
	</body>
</html>
